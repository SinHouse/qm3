import	qm3.utils._mpi
import	math
import	os


#-- object definition (my_problem)--


node, ncpu = qm3.utils._mpi.init()

os.mkdir( str( node ) )
os.chdir( str( node ) )

obj = my_problem( node )
obj.get_grad()

qm3.actions.dynamics.assign_velocities( obj, temperature = 300., project_RT = True )

dyn = qm3.actions.dynamics.langevin_verlet( obj, step_size = 0.0005,
	temperature = 300., gamma_factor = 50., print_frequency = 10,
	project_RT = True, log_function = obj.log )

for i in range( 10000 ):
	dyn.integrate()
	qm3.utils._mpi.barrier()
	if( node == 0 ):
		#-- obj.str is the name of the string engine --
		cvs   = obj.str
		tmp_c = cvs.rcrd[:]
		tmp_m = cvs.cmet[:]
		for i in range( 1, cvs.nwin ):
			tmp_c += qm3.utils._mpi.recv_r8( i, cvs.ncrd )
			tmp_m += qm3.utils._mpi.recv_r8( i, cvs.ncrd * cvs.ncrd )
		tmp_c = qm3.actions.string.string_distribute( cvs.ncrd, cvs.nwin, tmp_c, tmp_m )[0]
		cvs.rcrd = tmp_c[0:cvs.ncrd][:]
		for i in range( 1, cvs.nwin ):
			qm3.utils._mpi.send_r8( i, tmp_c[i*cvs.ncrd:(i+1)*cvs.ncrd] )
		cvs.fstr.write( "".join( [ "%20.10lf"%( tmp_c[j] ) for j in range( cvs.ncrd * cvs.nwin ) ] ) + "\n" )
		cvs.fstr.flush()
		ncrd2 = cvs.ncrd * cvs.ncrd
		tmp_a = []
		tmp_b = []
		for i in range( cvs.nwin ):
			tmp_i = qm3.maths.matrix.inverse( [ tmp_m[i*ncrd2+j] for j in range( ncrd2 ) ], cvs.ncrd, cvs.ncrd )
			tmp_a += [ tmp_c[i*cvs.ncrd+j] - cvs.icrd[i*cvs.ncrd+j] for j in range( cvs.ncrd ) ]
			tmp_b += qm3.maths.matrix.mult( tmp_i, cvs.ncrd, cvs.ncrd, tmp_a[i*cvs.ncrd:(i+1)*cvs.ncrd], cvs.ncrd, 1 )
		cvs.fcnv.write( "%20.10lf\n"%( math.sqrt( sum( [ tmp_a[i] * tmp_b[i] for i in range( cvs.ncrd * cvs.nwin ) ] ) / float( cvs.nwin ) ) ) )
		cvs.fcnv.flush()
	else:
		qm3.utils._mpi.send_r8( 0, obj.str.rcrd )
		qm3.utils._mpi.send_r8( 0, obj.str.cmet )
		obj.str.rcrd = qm3.utils._mpi.recv_r( 0, obj.str.ncrd )

obj.emm.stop()
obj.str.stop()
qm3.utils._mpi.stop()
