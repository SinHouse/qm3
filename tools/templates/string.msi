import	qm3.utils.msi
import	math
import	os


#-- object definition (my_problem)--


if( len( sys.argv ) == 1 ):
	#-- 18 windows --
	com = msi.server( 18 )
else:
	com = msi.client( sys.argv[1] )

os.mkdir( str( com.node ) )
os.chdir( str( com.node ) )

obj = my_problem( com.node )
obj.get_grad()

qm3.actions.dynamics.assign_velocities( obj, temperature = 300., project_RT = True )

dyn = qm3.actions.dynamics.langevin_verlet( obj, step_size = 0.0005,
	temperature = 300., gamma_factor = 50., print_frequency = 10,
	project_RT = True, log_function = obj.log )


for i in range( 10000 ):
	dyn.integrate()
	com.barrier()
	if( com.node == 0 ):
		#-- obj.str is the name of the string engine --
		cvs   = obj.str
		tmp_c = cvs.rcrd[:]
		tmp_m = cvs.cmet[:]
		for i in range( 1, cvs.nwin ):
			tmp_c += com.recv_r8( i, cvs.ncrd )
			tmp_m += com.recv_r8( i, cvs.ncrd * cvs.ncrd )
		tmp_c = qm3.actions.string.string_distribute( cvs.ncrd, cvs.nwin, tmp_c, tmp_m )[0]
		cvs.rcrd = tmp_c[0:cvs.ncrd][:]
		for i in range( 1, cvs.nwin ):
			com.send_r8( i, tmp_c[i*cvs.ncrd:(i+1)*cvs.ncrd] )
		cvs.fstr.write( "".join( [ "%20.10lf"%( tmp_c[j] ) for j in range( cvs.ncrd * cvs.nwin ) ] ) + "\n" )
		cvs.fstr.flush()
		ncrd2 = cvs.ncrd * cvs.ncrd
		tmp_a = []
		tmp_b = []
		for i in range( cvs.nwin ):
			tmp_i = qm3.maths.matrix.inverse( [ tmp_m[i*ncrd2+j] for j in range( ncrd2 ) ], cvs.ncrd, cvs.ncrd )
			tmp_a += [ tmp_c[i*cvs.ncrd+j] - cvs.icrd[i*cvs.ncrd+j] for j in range( cvs.ncrd ) ]
			tmp_b += qm3.maths.matrix.mult( tmp_i, cvs.ncrd, cvs.ncrd, tmp_a[i*cvs.ncrd:(i+1)*cvs.ncrd], cvs.ncrd, 1 )
		cvs.fcnv.write( "%20.10lf\n"%( math.sqrt( sum( [ tmp_a[i] * tmp_b[i] for i in range( cvs.ncrd * cvs.nwin ) ] ) / float( cvs.nwin ) ) ) )
		cvs.fcnv.flush()
	else:
		com.send_r8( obj.str.rcrd )
		com.send_r8( obj.str.cmet )
		obj.str.rcrd = com.recv_r8( obj.str.ncrd )


obj.str.stop()
com.stop()
